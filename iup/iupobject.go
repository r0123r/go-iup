// Copyright (C) 2011-2012 visualfc. All rights reserved.
// Use of this source code is governed by a MIT license
// that can be found in the COPYRIGHT file.

// gencb.lua
// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT

package iup

/*
#include "iupobject.h"
*/
import "C"
import (
	"unsafe"
)

func common_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	// case func(*CommonDefaultAction):
	// 	C.iupSetCommonDefaultAction(h.p)
	// 	h.funcs["CommonDefaultAction"] = fn
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	case func(*CommonUnmap):
		C.iupSetCommonUnmap(h.p)
		h.funcs["CommonUnmap"] = fn
	case func(*CommonDestroy):
		C.iupSetCommonDestroy(h.p)
		h.funcs["CommonDestroy"] = fn
	case func(*CommonGetFocus):
		C.iupSetCommonGetFocus(h.p)
		h.funcs["CommonGetFocus"] = fn
	case func(*CommonKillFocus):
		C.iupSetCommonKillFocus(h.p)
		h.funcs["CommonKillFocus"] = fn
	case func(*CommonEnterWindow):
		C.iupSetCommonEnterWindow(h.p)
		h.funcs["CommonEnterWindow"] = fn
	case func(*CommonLeaveWindow):
		C.iupSetCommonLeaveWindow(h.p)
		h.funcs["CommonLeaveWindow"] = fn
	case func(*CommonHelp):
		C.iupSetCommonHelp(h.p)
		h.funcs["CommonHelp"] = fn
	case func(*CommonKeyAny):
		C.iupSetCommonKeyAny(h.p)
		h.funcs["CommonKeyAny"] = fn
	default:
		return false
	}
	return true
}

func dialog_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*DialogClose):
		C.iupSetDialogClose(h.p)
		h.funcs["DialogClose"] = fn
	case func(*DialogResize):
		C.iupSetDialogResize(h.p)
		h.funcs["DialogResize"] = fn
	case func(*DialogDropFiles):
		C.iupSetDialogDropFiles(h.p)
		h.funcs["DialogDropFiles"] = fn
	case func(*DialogShow):
		C.iupSetDialogShow(h.p)
		h.funcs["DialogShow"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func filedlg_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*FileDlgFile):
		C.iupSetFileDlgFile(h.p)
		h.funcs["FileDlgFile"] = fn
	case func(*CommonHelp):
		C.iupSetCommonHelp(h.p)
		h.funcs["CommonHelp"] = fn
	default:
		return false
	}
	return true
}

func messagedlg_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*CommonHelp):
		C.iupSetCommonHelp(h.p)
		h.funcs["CommonHelp"] = fn
	default:
		return false
	}
	return true
}

func colordlg_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*CommonHelp):
		C.iupSetCommonHelp(h.p)
		h.funcs["CommonHelp"] = fn
	default:
		return false
	}
	return true
}

func fontdlg_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*CommonHelp):
		C.iupSetCommonHelp(h.p)
		h.funcs["CommonHelp"] = fn
	default:
		return false
	}
	return true
}

func fill_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func hbox_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func vbox_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func zbox_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func radio_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func normalizer_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func cbox_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func sbox_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func scrollbox_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func backgroundbox_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func split_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func item_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*ItemAction):
		C.iupSetItemAction(h.p)
		h.funcs["ItemAction"] = fn
	case func(*ItemHighlight):
		C.iupSetItemHighlight(h.p)
		h.funcs["ItemHighlight"] = fn
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	case func(*CommonUnmap):
		C.iupSetCommonUnmap(h.p)
		h.funcs["CommonUnmap"] = fn
	case func(*CommonHelp):
		C.iupSetCommonHelp(h.p)
		h.funcs["CommonHelp"] = fn
	default:
		return false
	}
	return true
}

func menu_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*MenuOpen):
		C.iupSetMenuOpen(h.p)
		h.funcs["MenuOpen"] = fn
	case func(*MenuClose):
		C.iupSetMenuClose(h.p)
		h.funcs["MenuClose"] = fn
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	case func(*CommonUnmap):
		C.iupSetCommonUnmap(h.p)
		h.funcs["CommonUnmap"] = fn
	default:
		return false
	}
	return true
}

func separator_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func submenu_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*SubMenuHighlight):
		C.iupSetSubMenuHighlight(h.p)
		h.funcs["SubMenuHighlight"] = fn
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	case func(*CommonUnmap):
		C.iupSetCommonUnmap(h.p)
		h.funcs["CommonUnmap"] = fn
	default:
		return false
	}
	return true
}

func clipboard_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func timer_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*TimerAction):
		C.iupSetTimerAction(h.p)
		h.funcs["TimerAction"] = fn
	default:
		return false
	}
	return true
}

func user_SetCallback(h *Handle, fn interface{}) bool {
	return false
}

func button_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*ButtonAction):
		C.iupSetButtonAction(h.p)
		h.funcs["ButtonAction"] = fn
	case func(*MouseButton):
		C.iupSetMouseButton(h.p)
		h.funcs["MouseButton"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func canvas_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*CanvasAction):
		C.iupSetCanvasAction(h.p)
		h.funcs["CanvasAction"] = fn
	case func(*MouseButton):
		C.iupSetMouseButton(h.p)
		h.funcs["MouseButton"] = fn
	case func(*CanvasDropFiles):
		C.iupSetCanvasDropFiles(h.p)
		h.funcs["CanvasDropFiles"] = fn
	case func(*CanvasFocus):
		C.iupSetCanvasFocus(h.p)
		h.funcs["CanvasFocus"] = fn
	case func(*MouseMotion):
		C.iupSetMouseMotion(h.p)
		h.funcs["MouseMotion"] = fn
	case func(*CanvasKeyPress):
		C.iupSetCanvasKeyPress(h.p)
		h.funcs["CanvasKeyPress"] = fn
	case func(*CanvasResize):
		C.iupSetCanvasResize(h.p)
		h.funcs["CanvasResize"] = fn
	case func(*CanvasScroll):
		C.iupSetCanvasScroll(h.p)
		h.funcs["CanvasScroll"] = fn
	case func(*TouchEvent):
		C.iupSetTouchEvent(h.p)
		h.funcs["TouchEvent"] = fn
	case func(*MultiTouchEvent):
		C.iupSetMultiTouchEvent(h.p)
		h.funcs["MultiTouchEvent"] = fn
	case func(*CanvasWheel):
		C.iupSetCanvasWheel(h.p)
		h.funcs["CanvasWheel"] = fn
	case func(*CanvasWom):
		C.iupSetCanvasWom(h.p)
		h.funcs["CanvasWom"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func frame_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	case func(*CommonUnmap):
		C.iupSetCommonUnmap(h.p)
		h.funcs["CommonUnmap"] = fn
	default:
		return false
	}
	return true
}

func label_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*MouseButton):
		C.iupSetMouseButton(h.p)
		h.funcs["MouseButton"] = fn
	case func(*LabelDropFiles):
		C.iupSetLabelDropFiles(h.p)
		h.funcs["LabelDropFiles"] = fn
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	case func(*CommonUnmap):
		C.iupSetCommonUnmap(h.p)
		h.funcs["CommonUnmap"] = fn
	case func(*CommonEnterWindow):
		C.iupSetCommonEnterWindow(h.p)
		h.funcs["CommonEnterWindow"] = fn
	case func(*CommonLeaveWindow):
		C.iupSetCommonLeaveWindow(h.p)
		h.funcs["CommonLeaveWindow"] = fn
	default:
		return false
	}
	return true
}

func list_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*ListAction):
		C.iupSetListAction(h.p)
		h.funcs["ListAction"] = fn
	case func(*MouseButton):
		C.iupSetMouseButton(h.p)
		h.funcs["MouseButton"] = fn
	case func(*ListCaret):
		C.iupSetListCaret(h.p)
		h.funcs["ListCaret"] = fn
	case func(*ListDblclick):
		C.iupSetListDblclick(h.p)
		h.funcs["ListDblclick"] = fn
	case func(*ListDropDown):
		C.iupSetListDropDown(h.p)
		h.funcs["ListDropDown"] = fn
	case func(*ListDropFiles):
		C.iupSetListDropFiles(h.p)
		h.funcs["ListDropFiles"] = fn
	case func(*ListEdit):
		C.iupSetListEdit(h.p)
		h.funcs["ListEdit"] = fn
	case func(*MouseMotion):
		C.iupSetMouseMotion(h.p)
		h.funcs["MouseMotion"] = fn
	case func(*ListMultiSelect):
		C.iupSetListMultiSelect(h.p)
		h.funcs["ListMultiSelect"] = fn
	case func(*ValueChanged):
		C.iupSetValueChanged(h.p)
		h.funcs["ValueChanged"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func progressbar_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	case func(*CommonUnmap):
		C.iupSetCommonUnmap(h.p)
		h.funcs["CommonUnmap"] = fn
	default:
		return false
	}
	return true
}

func spin_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*SpinInc):
		C.iupSetSpinInc(h.p)
		h.funcs["SpinInc"] = fn
	default:
		return false
	}
	return true
}

func spinbox_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*SpinBoxInc):
		C.iupSetSpinBoxInc(h.p)
		h.funcs["SpinBoxInc"] = fn
	default:
		return false
	}
	return true
}

func tabs_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*TabsChange):
		C.iupSetTabsChange(h.p)
		h.funcs["TabsChange"] = fn
	case func(*TabsChangePos):
		C.iupSetTabsChangePos(h.p)
		h.funcs["TabsChangePos"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func text_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*TextAction):
		C.iupSetTextAction(h.p)
		h.funcs["TextAction"] = fn
	case func(*MouseButton):
		C.iupSetMouseButton(h.p)
		h.funcs["MouseButton"] = fn
	case func(*TextCaret):
		C.iupSetTextCaret(h.p)
		h.funcs["TextCaret"] = fn
	case func(*TextDropFiles):
		C.iupSetTextDropFiles(h.p)
		h.funcs["TextDropFiles"] = fn
	case func(*MouseMotion):
		C.iupSetMouseMotion(h.p)
		h.funcs["MouseMotion"] = fn
	case func(*TextSpin):
		C.iupSetTextSpin(h.p)
		h.funcs["TextSpin"] = fn
	case func(*ValueChanged):
		C.iupSetValueChanged(h.p)
		h.funcs["ValueChanged"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func toggle_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*ToggleAction):
		C.iupSetToggleAction(h.p)
		h.funcs["ToggleAction"] = fn
	case func(*ValueChanged):
		C.iupSetValueChanged(h.p)
		h.funcs["ValueChanged"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func tree_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*TreeSelection):
		C.iupSetTreeSelection(h.p)
		h.funcs["TreeSelection"] = fn
	case func(*TreeMultiSelection):
		C.iupSetTreeMultiSelection(h.p)
		h.funcs["TreeMultiSelection"] = fn
	case func(*TreeBranchOpen):
		C.iupSetTreeBranchOpen(h.p)
		h.funcs["TreeBranchOpen"] = fn
	case func(*TreeBranchClose):
		C.iupSetTreeBranchClose(h.p)
		h.funcs["TreeBranchClose"] = fn
	case func(*TreeExecuteLeaf):
		C.iupSetTreeExecuteLeaf(h.p)
		h.funcs["TreeExecuteLeaf"] = fn
	case func(*TreeExecuteBranch):
		C.iupSetTreeExecuteBranch(h.p)
		h.funcs["TreeExecuteBranch"] = fn
	case func(*TreeShowRename):
		C.iupSetTreeShowRename(h.p)
		h.funcs["TreeShowRename"] = fn
	case func(*TreeRename):
		C.iupSetTreeRename(h.p)
		h.funcs["TreeRename"] = fn
	case func(*TreeDragDrop):
		C.iupSetTreeDragDrop(h.p)
		h.funcs["TreeDragDrop"] = fn
	case func(*TreeNodeRemoved):
		C.iupSetTreeNodeRemoved(h.p)
		h.funcs["TreeNodeRemoved"] = fn
	case func(*TreeRightClick):
		C.iupSetTreeRightClick(h.p)
		h.funcs["TreeRightClick"] = fn
	case func(*MouseButton):
		C.iupSetMouseButton(h.p)
		h.funcs["MouseButton"] = fn
	case func(*TreeDropFiles):
		C.iupSetTreeDropFiles(h.p)
		h.funcs["TreeDropFiles"] = fn
	case func(*MouseMotion):
		C.iupSetMouseMotion(h.p)
		h.funcs["MouseMotion"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func val_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*ValueChanged):
		C.iupSetValueChanged(h.p)
		h.funcs["ValueChanged"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func cells_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*CellsDraw):
		C.iupSetCellsDraw(h.p)
		h.funcs["CellsDraw"] = fn
	case func(*CellsHeight):
		C.iupSetCellsHeight(h.p)
		h.funcs["CellsHeight"] = fn
	case func(*CellsHspan):
		C.iupSetCellsHspan(h.p)
		h.funcs["CellsHspan"] = fn
	case func(*CellsMouseClick):
		C.iupSetCellsMouseClick(h.p)
		h.funcs["CellsMouseClick"] = fn
	case func(*CellsMouseMotion):
		C.iupSetCellsMouseMotion(h.p)
		h.funcs["CellsMouseMotion"] = fn
	case func(*CellsNcols):
		C.iupSetCellsNcols(h.p)
		h.funcs["CellsNcols"] = fn
	case func(*CellsNlines):
		C.iupSetCellsNlines(h.p)
		h.funcs["CellsNlines"] = fn
	case func(*CellsScrolling):
		C.iupSetCellsScrolling(h.p)
		h.funcs["CellsScrolling"] = fn
	case func(*CellsVspan):
		C.iupSetCellsVspan(h.p)
		h.funcs["CellsVspan"] = fn
	case func(*CellsWidth):
		C.iupSetCellsWidth(h.p)
		h.funcs["CellsWidth"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func colorbar_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*ColorbarCell):
		C.iupSetColorbarCell(h.p)
		h.funcs["ColorbarCell"] = fn
	case func(*ColorbarExtended):
		C.iupSetColorbarExtended(h.p)
		h.funcs["ColorbarExtended"] = fn
	case func(*ColorbarSelect):
		C.iupSetColorbarSelect(h.p)
		h.funcs["ColorbarSelect"] = fn
	case func(*ColorbarSwitch):
		C.iupSetColorbarSwitch(h.p)
		h.funcs["ColorbarSwitch"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func colorbrowser_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*ColorBrowserChange):
		C.iupSetColorBrowserChange(h.p)
		h.funcs["ColorBrowserChange"] = fn
	case func(*ColorBrowserDrag):
		C.iupSetColorBrowserDrag(h.p)
		h.funcs["ColorBrowserDrag"] = fn
	case func(*ValueChanged):
		C.iupSetValueChanged(h.p)
		h.funcs["ValueChanged"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func dial_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*DialButtonPress):
		C.iupSetDialButtonPress(h.p)
		h.funcs["DialButtonPress"] = fn
	case func(*DialButtonRelease):
		C.iupSetDialButtonRelease(h.p)
		h.funcs["DialButtonRelease"] = fn
	case func(*DialMouseMove):
		C.iupSetDialMouseMove(h.p)
		h.funcs["DialMouseMove"] = fn
	case func(*ValueChanged):
		C.iupSetValueChanged(h.p)
		h.funcs["ValueChanged"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func matrix_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*MatrixAction):
		C.iupSetMatrixAction(h.p)
		h.funcs["MatrixAction"] = fn
	case func(*MatrixClick):
		C.iupSetMatrixClick(h.p)
		h.funcs["MatrixClick"] = fn
	case func(*MatrixRelease):
		C.iupSetMatrixRelease(h.p)
		h.funcs["MatrixRelease"] = fn
	case func(*MatrixMouseMove):
		C.iupSetMatrixMouseMove(h.p)
		h.funcs["MatrixMouseMove"] = fn
	case func(*MatrixEnterItem):
		C.iupSetMatrixEnterItem(h.p)
		h.funcs["MatrixEnterItem"] = fn
	case func(*MatrixLeaveItem):
		C.iupSetMatrixLeaveItem(h.p)
		h.funcs["MatrixLeaveItem"] = fn
	case func(*MatrixScrollTop):
		C.iupSetMatrixScrollTop(h.p)
		h.funcs["MatrixScrollTop"] = fn
	case func(*MatrixBgcolor):
		C.iupSetMatrixBgcolor(h.p)
		h.funcs["MatrixBgcolor"] = fn
	case func(*MatrixFgcolor):
		C.iupSetMatrixFgcolor(h.p)
		h.funcs["MatrixFgcolor"] = fn
	case func(*MatrixFont):
		C.iupSetMatrixFont(h.p)
		h.funcs["MatrixFont"] = fn
	case func(*MatrixDraw):
		C.iupSetMatrixDraw(h.p)
		h.funcs["MatrixDraw"] = fn
	case func(*MatrixDropCheck):
		C.iupSetMatrixDropCheck(h.p)
		h.funcs["MatrixDropCheck"] = fn
	case func(*MatrixDrop):
		C.iupSetMatrixDrop(h.p)
		h.funcs["MatrixDrop"] = fn
	case func(*MatrixDropSelect):
		C.iupSetMatrixDropSelect(h.p)
		h.funcs["MatrixDropSelect"] = fn
	case func(*MatrixEdition):
		C.iupSetMatrixEdition(h.p)
		h.funcs["MatrixEdition"] = fn
	case func(*MatrixValue):
		C.iupSetMatrixValue(h.p)
		h.funcs["MatrixValue"] = fn
	case func(*MatrixValueEdit):
		C.iupSetMatrixValueEdit(h.p)
		h.funcs["MatrixValueEdit"] = fn
	case func(*MatrixMark):
		C.iupSetMatrixMark(h.p)
		h.funcs["MatrixMark"] = fn
	case func(*MatrixMarkEdit):
		C.iupSetMatrixMarkEdit(h.p)
		h.funcs["MatrixMarkEdit"] = fn
	case func(*CanvasAction):
		C.iupSetCanvasAction(h.p)
		h.funcs["CanvasAction"] = fn
	case func(*CanvasScroll):
		C.iupSetCanvasScroll(h.p)
		h.funcs["CanvasScroll"] = fn
	case func(*CanvasKeyPress):
		C.iupSetCanvasKeyPress(h.p)
		h.funcs["CanvasKeyPress"] = fn
	case func(*MouseMotion):
		C.iupSetMouseMotion(h.p)
		h.funcs["MouseMotion"] = fn
	case func(*CanvasResize):
		C.iupSetCanvasResize(h.p)
		h.funcs["CanvasResize"] = fn
	case func(*MouseButton):
		C.iupSetMouseButton(h.p)
		h.funcs["MouseButton"] = fn
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	default:
		return false
	}
	return true
}

func olecontrol_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*CommonMap):
		C.iupSetCommonMap(h.p)
		h.funcs["CommonMap"] = fn
	case func(*CommonUnmap):
		C.iupSetCommonUnmap(h.p)
		h.funcs["CommonUnmap"] = fn
	case func(*CommonGetFocus):
		C.iupSetCommonGetFocus(h.p)
		h.funcs["CommonGetFocus"] = fn
	case func(*CommonKillFocus):
		C.iupSetCommonKillFocus(h.p)
		h.funcs["CommonKillFocus"] = fn
	case func(*CommonEnterWindow):
		C.iupSetCommonEnterWindow(h.p)
		h.funcs["CommonEnterWindow"] = fn
	case func(*CommonLeaveWindow):
		C.iupSetCommonLeaveWindow(h.p)
		h.funcs["CommonLeaveWindow"] = fn
	default:
		return false
	}
	return true
}

func pplot_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*PPlotDelete):
		C.iupSetPPlotDelete(h.p)
		h.funcs["PPlotDelete"] = fn
	case func(*PPlotDeleteBegin):
		C.iupSetPPlotDeleteBegin(h.p)
		h.funcs["PPlotDeleteBegin"] = fn
	case func(*PPlotDeleteEnd):
		C.iupSetPPlotDeleteEnd(h.p)
		h.funcs["PPlotDeleteEnd"] = fn
	case func(*PPlotSelect):
		C.iupSetPPlotSelect(h.p)
		h.funcs["PPlotSelect"] = fn
	case func(*PPlotSelectBegin):
		C.iupSetPPlotSelectBegin(h.p)
		h.funcs["PPlotSelectBegin"] = fn
	case func(*PPlotSelectEnd):
		C.iupSetPPlotSelectEnd(h.p)
		h.funcs["PPlotSelectEnd"] = fn
	case func(*PPlotEdit):
		C.iupSetPPlotEdit(h.p)
		h.funcs["PPlotEdit"] = fn
	case func(*PPlotEditBegin):
		C.iupSetPPlotEditBegin(h.p)
		h.funcs["PPlotEditBegin"] = fn
	case func(*PPlotEditEnd):
		C.iupSetPPlotEditEnd(h.p)
		h.funcs["PPlotEditEnd"] = fn
	case func(*PPlotPreDraw):
		C.iupSetPPlotPreDraw(h.p)
		h.funcs["PPlotPreDraw"] = fn
	case func(*PPlotPostDraw):
		C.iupSetPPlotPostDraw(h.p)
		h.funcs["PPlotPostDraw"] = fn
	case func(*PlotMotion):
		C.iupSetPlotMotion(h.p)
		h.funcs["PlotMotion"] = fn
	case func(*PlotXtick):
		C.iupSetPlotXtick(h.p)
		h.funcs["PlotXtick"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func webbrowser_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*WebBrowserCompleted):
		C.iupSetWebBrowserCompleted(h.p)
		h.funcs["WebBrowserCompleted"] = fn
	case func(*WebBrowserError):
		C.iupSetWebBrowserError(h.p)
		h.funcs["WebBrowserError"] = fn
	case func(*WebBrowserNavigate):
		C.iupSetWebBrowserNavigate(h.p)
		h.funcs["WebBrowserNavigate"] = fn
	case func(*WebBrowserNewWindow):
		C.iupSetWebBrowserNewWindow(h.p)
		h.funcs["WebBrowserNewWindow"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

func tuioclient_SetCallback(h *Handle, fn interface{}) bool {
	switch fn.(type) {
	case func(*TouchEvent):
		C.iupSetTouchEvent(h.p)
		h.funcs["TouchEvent"] = fn
	case func(*MultiTouchEvent):
		C.iupSetMultiTouchEvent(h.p)
		h.funcs["MultiTouchEvent"] = fn
	default:
		return common_SetCallback(h, fn)
	}
	return true
}

//export goCommonDefaultAction
func goCommonDefaultAction(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonDefaultAction"]; ok {
			if fn, ok := f.(func(*CommonDefaultAction)); ok {
				arg := &CommonDefaultAction{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonMap
func goCommonMap(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonMap"]; ok {
			if fn, ok := f.(func(*CommonMap)); ok {
				arg := &CommonMap{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonUnmap
func goCommonUnmap(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonUnmap"]; ok {
			if fn, ok := f.(func(*CommonUnmap)); ok {
				arg := &CommonUnmap{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonDestroy
func goCommonDestroy(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonDestroy"]; ok {
			if fn, ok := f.(func(*CommonDestroy)); ok {
				arg := &CommonDestroy{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonGetFocus
func goCommonGetFocus(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonGetFocus"]; ok {
			if fn, ok := f.(func(*CommonGetFocus)); ok {
				arg := &CommonGetFocus{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonKillFocus
func goCommonKillFocus(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonKillFocus"]; ok {
			if fn, ok := f.(func(*CommonKillFocus)); ok {
				arg := &CommonKillFocus{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonEnterWindow
func goCommonEnterWindow(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonEnterWindow"]; ok {
			if fn, ok := f.(func(*CommonEnterWindow)); ok {
				arg := &CommonEnterWindow{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonLeaveWindow
func goCommonLeaveWindow(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonLeaveWindow"]; ok {
			if fn, ok := f.(func(*CommonLeaveWindow)); ok {
				arg := &CommonLeaveWindow{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonHelp
func goCommonHelp(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonHelp"]; ok {
			if fn, ok := f.(func(*CommonHelp)); ok {
				arg := &CommonHelp{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCommonKeyAny
func goCommonKeyAny(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CommonKeyAny"]; ok {
			if fn, ok := f.(func(*CommonKeyAny)); ok {
				arg := &CommonKeyAny{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goDialogClose
func goDialogClose(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["DialogClose"]; ok {
			if fn, ok := f.(func(*DialogClose)); ok {
				arg := &DialogClose{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goDialogResize
func goDialogResize(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["DialogResize"]; ok {
			if fn, ok := f.(func(*DialogResize)); ok {
				arg := &DialogResize{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goDialogDropFiles
func goDialogDropFiles(p unsafe.Pointer, N1 *C.char, N2 int32, N3 int32, N4 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["DialogDropFiles"]; ok {
			if fn, ok := f.(func(*DialogDropFiles)); ok {
				arg := &DialogDropFiles{h, DEFAULT, C.GoString(N1), N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goDialogShow
func goDialogShow(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["DialogShow"]; ok {
			if fn, ok := f.(func(*DialogShow)); ok {
				arg := &DialogShow{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goFileDlgFile
func goFileDlgFile(p unsafe.Pointer, N1 *C.char, N2 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["FileDlgFile"]; ok {
			if fn, ok := f.(func(*FileDlgFile)); ok {
				arg := &FileDlgFile{h, DEFAULT, C.GoString(N1), C.GoString(N2)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goItemAction
func goItemAction(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ItemAction"]; ok {
			if fn, ok := f.(func(*ItemAction)); ok {
				arg := &ItemAction{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goItemHighlight
func goItemHighlight(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ItemHighlight"]; ok {
			if fn, ok := f.(func(*ItemHighlight)); ok {
				arg := &ItemHighlight{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMenuOpen
func goMenuOpen(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MenuOpen"]; ok {
			if fn, ok := f.(func(*MenuOpen)); ok {
				arg := &MenuOpen{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMenuClose
func goMenuClose(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MenuClose"]; ok {
			if fn, ok := f.(func(*MenuClose)); ok {
				arg := &MenuClose{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goSubMenuHighlight
func goSubMenuHighlight(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["SubMenuHighlight"]; ok {
			if fn, ok := f.(func(*SubMenuHighlight)); ok {
				arg := &SubMenuHighlight{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTimerAction
func goTimerAction(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TimerAction"]; ok {
			if fn, ok := f.(func(*TimerAction)); ok {
				arg := &TimerAction{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goButtonAction
func goButtonAction(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ButtonAction"]; ok {
			if fn, ok := f.(func(*ButtonAction)); ok {
				arg := &ButtonAction{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMouseButton
func goMouseButton(p unsafe.Pointer, N1 int32, N2 int32, N3 int32, N4 int32, N5 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MouseButton"]; ok {
			if fn, ok := f.(func(*MouseButton)); ok {
				arg := &MouseButton{h, DEFAULT, N1, N2, N3, N4, C.GoString(N5)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCanvasAction
func goCanvasAction(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CanvasAction"]; ok {
			if fn, ok := f.(func(*CanvasAction)); ok {
				arg := &CanvasAction{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCanvasDropFiles
func goCanvasDropFiles(p unsafe.Pointer, N1 *C.char, N2 int32, N3 int32, N4 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CanvasDropFiles"]; ok {
			if fn, ok := f.(func(*CanvasDropFiles)); ok {
				arg := &CanvasDropFiles{h, DEFAULT, C.GoString(N1), N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCanvasFocus
func goCanvasFocus(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CanvasFocus"]; ok {
			if fn, ok := f.(func(*CanvasFocus)); ok {
				arg := &CanvasFocus{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMouseMotion
func goMouseMotion(p unsafe.Pointer, N1 int32, N2 int32, N3 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MouseMotion"]; ok {
			if fn, ok := f.(func(*MouseMotion)); ok {
				arg := &MouseMotion{h, DEFAULT, N1, N2, C.GoString(N3)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPlotMotion
func goPlotMotion(p unsafe.Pointer, N1 float64, N2 float64, N3 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PlotMotion"]; ok {
			if fn, ok := f.(func(*PlotMotion)); ok {
				arg := &PlotMotion{h, DEFAULT, N1, N2, C.GoString(N3)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPlotXtick
func goPlotXtick(p unsafe.Pointer, N1, N2 *C.char, x float64, N3 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PlotXtick"]; ok {
			if fn, ok := f.(func(*PlotXtick)); ok {
				arg := &PlotXtick{h, DEFAULT, C.GoString(N1), C.GoString(N2), x, C.GoString(N3)}
				fn(arg)
				v := []byte(arg.Buffer)
				v = append(v, 0)
				C.memcpy(unsafe.Pointer(N1), unsafe.Pointer(&v[0]), C.size_t(len(v)))
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCanvasKeyPress
func goCanvasKeyPress(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CanvasKeyPress"]; ok {
			if fn, ok := f.(func(*CanvasKeyPress)); ok {
				arg := &CanvasKeyPress{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCanvasResize
func goCanvasResize(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CanvasResize"]; ok {
			if fn, ok := f.(func(*CanvasResize)); ok {
				arg := &CanvasResize{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCanvasScroll
func goCanvasScroll(p unsafe.Pointer, N1 int32, N2 float32, N3 float32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CanvasScroll"]; ok {
			if fn, ok := f.(func(*CanvasScroll)); ok {
				arg := &CanvasScroll{h, DEFAULT, N1, N2, N3}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTouchEvent
func goTouchEvent(p unsafe.Pointer, N1 int32, N2 int32, N3 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TouchEvent"]; ok {
			if fn, ok := f.(func(*TouchEvent)); ok {
				arg := &TouchEvent{h, DEFAULT, N1, N2, C.GoString(N3)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMultiTouchEvent
func goMultiTouchEvent(p unsafe.Pointer, N1 int32, N2 *int32, N3 *int32, N4 *int32, N5 *int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MultiTouchEvent"]; ok {
			if fn, ok := f.(func(*MultiTouchEvent)); ok {
				arg := &MultiTouchEvent{h, DEFAULT, N1, N2, N3, N4, N5}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCanvasWheel
func goCanvasWheel(p unsafe.Pointer, N1 float32, N2 int32, N3 int32, N4 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CanvasWheel"]; ok {
			if fn, ok := f.(func(*CanvasWheel)); ok {
				arg := &CanvasWheel{h, DEFAULT, N1, N2, N3, C.GoString(N4)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCanvasWom
func goCanvasWom(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CanvasWom"]; ok {
			if fn, ok := f.(func(*CanvasWom)); ok {
				arg := &CanvasWom{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goLabelDropFiles
func goLabelDropFiles(p unsafe.Pointer, N1 *C.char, N2 int32, N3 int32, N4 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["LabelDropFiles"]; ok {
			if fn, ok := f.(func(*LabelDropFiles)); ok {
				arg := &LabelDropFiles{h, DEFAULT, C.GoString(N1), N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goListAction
func goListAction(p unsafe.Pointer, N1 *C.char, N2 int32, N3 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ListAction"]; ok {
			if fn, ok := f.(func(*ListAction)); ok {
				arg := &ListAction{h, DEFAULT, C.GoString(N1), N2, N3}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goListCaret
func goListCaret(p unsafe.Pointer, N1 int32, N2 int32, N3 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ListCaret"]; ok {
			if fn, ok := f.(func(*ListCaret)); ok {
				arg := &ListCaret{h, DEFAULT, N1, N2, N3}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goListDblclick
func goListDblclick(p unsafe.Pointer, N1 int32, N2 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ListDblclick"]; ok {
			if fn, ok := f.(func(*ListDblclick)); ok {
				arg := &ListDblclick{h, DEFAULT, N1, C.GoString(N2)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goListDropDown
func goListDropDown(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ListDropDown"]; ok {
			if fn, ok := f.(func(*ListDropDown)); ok {
				arg := &ListDropDown{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goListDropFiles
func goListDropFiles(p unsafe.Pointer, N1 *C.char, N2 int32, N3 int32, N4 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ListDropFiles"]; ok {
			if fn, ok := f.(func(*ListDropFiles)); ok {
				arg := &ListDropFiles{h, DEFAULT, C.GoString(N1), N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goListEdit
func goListEdit(p unsafe.Pointer, N1 int32, N2 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ListEdit"]; ok {
			if fn, ok := f.(func(*ListEdit)); ok {
				arg := &ListEdit{h, DEFAULT, N1, C.GoString(N2)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goListMultiSelect
func goListMultiSelect(p unsafe.Pointer, N1 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ListMultiSelect"]; ok {
			if fn, ok := f.(func(*ListMultiSelect)); ok {
				arg := &ListMultiSelect{h, DEFAULT, C.GoString(N1)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goValueChanged
func goValueChanged(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ValueChanged"]; ok {
			if fn, ok := f.(func(*ValueChanged)); ok {
				arg := &ValueChanged{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goSpinInc
func goSpinInc(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["SpinInc"]; ok {
			if fn, ok := f.(func(*SpinInc)); ok {
				arg := &SpinInc{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goSpinBoxInc
func goSpinBoxInc(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["SpinBoxInc"]; ok {
			if fn, ok := f.(func(*SpinBoxInc)); ok {
				arg := &SpinBoxInc{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTabsChange
func goTabsChange(p unsafe.Pointer, N1 unsafe.Pointer, N2 unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TabsChange"]; ok {
			if fn, ok := f.(func(*TabsChange)); ok {
				arg := &TabsChange{h, DEFAULT, (*Handle)(N1), (*Handle)(N2)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTabsChangePos
func goTabsChangePos(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TabsChangePos"]; ok {
			if fn, ok := f.(func(*TabsChangePos)); ok {
				arg := &TabsChangePos{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTextAction
func goTextAction(p unsafe.Pointer, N1 int32, N2 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TextAction"]; ok {
			if fn, ok := f.(func(*TextAction)); ok {
				arg := &TextAction{h, DEFAULT, N1, C.GoString(N2)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTextCaret
func goTextCaret(p unsafe.Pointer, N1 int32, N2 int32, N3 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TextCaret"]; ok {
			if fn, ok := f.(func(*TextCaret)); ok {
				arg := &TextCaret{h, DEFAULT, N1, N2, N3}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTextDropFiles
func goTextDropFiles(p unsafe.Pointer, N1 *C.char, N2 int32, N3 int32, N4 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TextDropFiles"]; ok {
			if fn, ok := f.(func(*TextDropFiles)); ok {
				arg := &TextDropFiles{h, DEFAULT, C.GoString(N1), N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTextSpin
func goTextSpin(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TextSpin"]; ok {
			if fn, ok := f.(func(*TextSpin)); ok {
				arg := &TextSpin{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goToggleAction
func goToggleAction(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ToggleAction"]; ok {
			if fn, ok := f.(func(*ToggleAction)); ok {
				arg := &ToggleAction{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeSelection
func goTreeSelection(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeSelection"]; ok {
			if fn, ok := f.(func(*TreeSelection)); ok {
				arg := &TreeSelection{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeMultiSelection
func goTreeMultiSelection(p unsafe.Pointer, N1 *int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeMultiSelection"]; ok {
			if fn, ok := f.(func(*TreeMultiSelection)); ok {
				arg := &TreeMultiSelection{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeBranchOpen
func goTreeBranchOpen(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeBranchOpen"]; ok {
			if fn, ok := f.(func(*TreeBranchOpen)); ok {
				arg := &TreeBranchOpen{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeBranchClose
func goTreeBranchClose(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeBranchClose"]; ok {
			if fn, ok := f.(func(*TreeBranchClose)); ok {
				arg := &TreeBranchClose{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeExecuteLeaf
func goTreeExecuteLeaf(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeExecuteLeaf"]; ok {
			if fn, ok := f.(func(*TreeExecuteLeaf)); ok {
				arg := &TreeExecuteLeaf{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeExecuteBranch
func goTreeExecuteBranch(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeExecuteBranch"]; ok {
			if fn, ok := f.(func(*TreeExecuteBranch)); ok {
				arg := &TreeExecuteBranch{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeShowRename
func goTreeShowRename(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeShowRename"]; ok {
			if fn, ok := f.(func(*TreeShowRename)); ok {
				arg := &TreeShowRename{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeRename
func goTreeRename(p unsafe.Pointer, N1 int32, N2 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeRename"]; ok {
			if fn, ok := f.(func(*TreeRename)); ok {
				arg := &TreeRename{h, DEFAULT, N1, C.GoString(N2)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeDragDrop
func goTreeDragDrop(p unsafe.Pointer, N1 int32, N2 int32, N3 int32, N4 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeDragDrop"]; ok {
			if fn, ok := f.(func(*TreeDragDrop)); ok {
				arg := &TreeDragDrop{h, DEFAULT, N1, N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeNodeRemoved
func goTreeNodeRemoved(p unsafe.Pointer, N1 unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeNodeRemoved"]; ok {
			if fn, ok := f.(func(*TreeNodeRemoved)); ok {
				arg := &TreeNodeRemoved{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeRightClick
func goTreeRightClick(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeRightClick"]; ok {
			if fn, ok := f.(func(*TreeRightClick)); ok {
				arg := &TreeRightClick{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goTreeDropFiles
func goTreeDropFiles(p unsafe.Pointer, N1 *C.char, N2 int32, N3 int32, N4 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["TreeDropFiles"]; ok {
			if fn, ok := f.(func(*TreeDropFiles)); ok {
				arg := &TreeDropFiles{h, DEFAULT, C.GoString(N1), N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsDraw
func goCellsDraw(p unsafe.Pointer, N1 int32, N2 int32, N3 int32, N4 int32, N5 int32, N6 int32, N7 unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsDraw"]; ok {
			if fn, ok := f.(func(*CellsDraw)); ok {
				arg := &CellsDraw{h, DEFAULT, N1, N2, N3, N4, N5, N6, N7}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsHeight
func goCellsHeight(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsHeight"]; ok {
			if fn, ok := f.(func(*CellsHeight)); ok {
				arg := &CellsHeight{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsHspan
func goCellsHspan(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsHspan"]; ok {
			if fn, ok := f.(func(*CellsHspan)); ok {
				arg := &CellsHspan{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsMouseClick
func goCellsMouseClick(p unsafe.Pointer, N1 int32, N2 int32, N3 int32, N4 int32, N5 int32, N6 int32, N7 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsMouseClick"]; ok {
			if fn, ok := f.(func(*CellsMouseClick)); ok {
				arg := &CellsMouseClick{h, DEFAULT, N1, N2, N3, N4, N5, N6, C.GoString(N7)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsMouseMotion
func goCellsMouseMotion(p unsafe.Pointer, N1 int32, N2 int32, N3 int32, N4 int32, N5 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsMouseMotion"]; ok {
			if fn, ok := f.(func(*CellsMouseMotion)); ok {
				arg := &CellsMouseMotion{h, DEFAULT, N1, N2, N3, N4, C.GoString(N5)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsNcols
func goCellsNcols(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsNcols"]; ok {
			if fn, ok := f.(func(*CellsNcols)); ok {
				arg := &CellsNcols{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsNlines
func goCellsNlines(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsNlines"]; ok {
			if fn, ok := f.(func(*CellsNlines)); ok {
				arg := &CellsNlines{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsScrolling
func goCellsScrolling(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsScrolling"]; ok {
			if fn, ok := f.(func(*CellsScrolling)); ok {
				arg := &CellsScrolling{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsVspan
func goCellsVspan(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsVspan"]; ok {
			if fn, ok := f.(func(*CellsVspan)); ok {
				arg := &CellsVspan{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goCellsWidth
func goCellsWidth(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["CellsWidth"]; ok {
			if fn, ok := f.(func(*CellsWidth)); ok {
				arg := &CellsWidth{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goColorbarCell
func goColorbarCell(p unsafe.Pointer, N1 int32) *C.char {
	ih := ptoHandle(p)
	if ih == nil {
		return nil
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ColorbarCell"]; ok {
			if fn, ok := f.(func(*ColorbarCell)); ok {
				arg := &ColorbarCell{h, "", N1}
				fn(arg)
				size := len(arg.Return)
				ch := make([]byte, size+1)
				copy(ch, arg.Return)
				ch[size] = 0
				return (*C.char)(unsafe.Pointer(&ch[0]))
			}
		}
	}
	return nil
}

//export goColorbarExtended
func goColorbarExtended(p unsafe.Pointer, N1 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ColorbarExtended"]; ok {
			if fn, ok := f.(func(*ColorbarExtended)); ok {
				arg := &ColorbarExtended{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goColorbarSelect
func goColorbarSelect(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ColorbarSelect"]; ok {
			if fn, ok := f.(func(*ColorbarSelect)); ok {
				arg := &ColorbarSelect{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goColorbarSwitch
func goColorbarSwitch(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ColorbarSwitch"]; ok {
			if fn, ok := f.(func(*ColorbarSwitch)); ok {
				arg := &ColorbarSwitch{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goColorBrowserChange
func goColorBrowserChange(p unsafe.Pointer, N1 C.uchar, N2 C.uchar, N3 C.uchar) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ColorBrowserChange"]; ok {
			if fn, ok := f.(func(*ColorBrowserChange)); ok {
				arg := &ColorBrowserChange{h, DEFAULT, byte(N1), byte(N2), byte(N3)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goColorBrowserDrag
func goColorBrowserDrag(p unsafe.Pointer, N1 C.uchar, N2 C.uchar, N3 C.uchar) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["ColorBrowserDrag"]; ok {
			if fn, ok := f.(func(*ColorBrowserDrag)); ok {
				arg := &ColorBrowserDrag{h, DEFAULT, byte(N1), byte(N2), byte(N3)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goDialButtonPress
func goDialButtonPress(p unsafe.Pointer, N1 float64) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["DialButtonPress"]; ok {
			if fn, ok := f.(func(*DialButtonPress)); ok {
				arg := &DialButtonPress{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goDialButtonRelease
func goDialButtonRelease(p unsafe.Pointer, N1 float64) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["DialButtonRelease"]; ok {
			if fn, ok := f.(func(*DialButtonRelease)); ok {
				arg := &DialButtonRelease{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goDialMouseMove
func goDialMouseMove(p unsafe.Pointer, N1 float64) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["DialMouseMove"]; ok {
			if fn, ok := f.(func(*DialMouseMove)); ok {
				arg := &DialMouseMove{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixAction
func goMatrixAction(p unsafe.Pointer, N1 int32, N2 int32, N3 int32, N4 int32, N5 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixAction"]; ok {
			if fn, ok := f.(func(*MatrixAction)); ok {
				arg := &MatrixAction{h, DEFAULT, N1, N2, N3, N4, C.GoString(N5)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixClick
func goMatrixClick(p unsafe.Pointer, N1 int32, N2 int32, N3 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixClick"]; ok {
			if fn, ok := f.(func(*MatrixClick)); ok {
				arg := &MatrixClick{h, DEFAULT, N1, N2, C.GoString(N3)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixRelease
func goMatrixRelease(p unsafe.Pointer, N1 int32, N2 int32, N3 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixRelease"]; ok {
			if fn, ok := f.(func(*MatrixRelease)); ok {
				arg := &MatrixRelease{h, DEFAULT, N1, N2, C.GoString(N3)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixMouseMove
func goMatrixMouseMove(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixMouseMove"]; ok {
			if fn, ok := f.(func(*MatrixMouseMove)); ok {
				arg := &MatrixMouseMove{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixEnterItem
func goMatrixEnterItem(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixEnterItem"]; ok {
			if fn, ok := f.(func(*MatrixEnterItem)); ok {
				arg := &MatrixEnterItem{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixLeaveItem
func goMatrixLeaveItem(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixLeaveItem"]; ok {
			if fn, ok := f.(func(*MatrixLeaveItem)); ok {
				arg := &MatrixLeaveItem{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixScrollTop
func goMatrixScrollTop(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixScrollTop"]; ok {
			if fn, ok := f.(func(*MatrixScrollTop)); ok {
				arg := &MatrixScrollTop{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixBgcolor
func goMatrixBgcolor(p unsafe.Pointer, N1 int32, N2 int32, N3 *C.uint, N4 *C.uint, N5 *C.uint) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixBgcolor"]; ok {
			if fn, ok := f.(func(*MatrixBgcolor)); ok {
				arg := &MatrixBgcolor{h, DEFAULT, N1, N2, (*uint)(unsafe.Pointer(N3)), (*uint)(unsafe.Pointer(N4)), (*uint)(unsafe.Pointer(N5))}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixFgcolor
func goMatrixFgcolor(p unsafe.Pointer, N1 int32, N2 int32, N3 *C.uint, N4 *C.uint, N5 *C.uint) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixFgcolor"]; ok {
			if fn, ok := f.(func(*MatrixFgcolor)); ok {
				arg := &MatrixFgcolor{h, DEFAULT, N1, N2, (*uint)(unsafe.Pointer(N3)), (*uint)(unsafe.Pointer(N4)), (*uint)(unsafe.Pointer(N5))}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixFont
func goMatrixFont(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixFont"]; ok {
			if fn, ok := f.(func(*MatrixFont)); ok {
				arg := &MatrixFont{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixDraw
func goMatrixDraw(p unsafe.Pointer, N1 int32, N2 int32, N3 int32, N4 int32, N5 int32, N6 int32, N7 unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixDraw"]; ok {
			if fn, ok := f.(func(*MatrixDraw)); ok {
				arg := &MatrixDraw{h, DEFAULT, N1, N2, N3, N4, N5, N6, N7}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixDropCheck
func goMatrixDropCheck(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixDropCheck"]; ok {
			if fn, ok := f.(func(*MatrixDropCheck)); ok {
				arg := &MatrixDropCheck{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixDrop
func goMatrixDrop(p unsafe.Pointer, drop unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixDrop"]; ok {
			if fn, ok := f.(func(*MatrixDrop)); ok {
				arg := &MatrixDrop{h, (*Handle)(drop), DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixDropSelect
func goMatrixDropSelect(p unsafe.Pointer, N1 int32, N2 int32, N3 unsafe.Pointer, N4 *C.char, N5 int32, N6 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixDropSelect"]; ok {
			if fn, ok := f.(func(*MatrixDropSelect)); ok {
				arg := &MatrixDropSelect{h, DEFAULT, N1, N2, (*Handle)(N3), C.GoString(N4), N5, N6}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixEdition
func goMatrixEdition(p unsafe.Pointer, N1 int32, N2 int32, N3 int32, N4 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixEdition"]; ok {
			if fn, ok := f.(func(*MatrixEdition)); ok {
				arg := &MatrixEdition{h, DEFAULT, N1, N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixValue
func goMatrixValue(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixValue"]; ok {
			if fn, ok := f.(func(*MatrixValue)); ok {
				arg := &MatrixValue{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixValueEdit
func goMatrixValueEdit(p unsafe.Pointer, N1 int32, N2 int32, N3 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixValueEdit"]; ok {
			if fn, ok := f.(func(*MatrixValueEdit)); ok {
				arg := &MatrixValueEdit{h, DEFAULT, N1, N2, C.GoString(N3)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixMark
func goMatrixMark(p unsafe.Pointer, N1 int32, N2 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixMark"]; ok {
			if fn, ok := f.(func(*MatrixMark)); ok {
				arg := &MatrixMark{h, DEFAULT, N1, N2}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goMatrixMarkEdit
func goMatrixMarkEdit(p unsafe.Pointer, N1 int32, N2 int32, N3 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["MatrixMarkEdit"]; ok {
			if fn, ok := f.(func(*MatrixMarkEdit)); ok {
				arg := &MatrixMarkEdit{h, DEFAULT, N1, N2, N3}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotDelete
func goPPlotDelete(p unsafe.Pointer, N1 int32, N2 int32, N3 float32, N4 float32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotDelete"]; ok {
			if fn, ok := f.(func(*PPlotDelete)); ok {
				arg := &PPlotDelete{h, DEFAULT, N1, N2, N3, N4}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotDeleteBegin
func goPPlotDeleteBegin(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotDeleteBegin"]; ok {
			if fn, ok := f.(func(*PPlotDeleteBegin)); ok {
				arg := &PPlotDeleteBegin{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotDeleteEnd
func goPPlotDeleteEnd(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotDeleteEnd"]; ok {
			if fn, ok := f.(func(*PPlotDeleteEnd)); ok {
				arg := &PPlotDeleteEnd{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotSelect
func goPPlotSelect(p unsafe.Pointer, N1 int32, N2 int32, N3 float32, N4 float32, N5 int32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotSelect"]; ok {
			if fn, ok := f.(func(*PPlotSelect)); ok {
				arg := &PPlotSelect{h, DEFAULT, N1, N2, N3, N4, N5}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotSelectBegin
func goPPlotSelectBegin(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotSelectBegin"]; ok {
			if fn, ok := f.(func(*PPlotSelectBegin)); ok {
				arg := &PPlotSelectBegin{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotSelectEnd
func goPPlotSelectEnd(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotSelectEnd"]; ok {
			if fn, ok := f.(func(*PPlotSelectEnd)); ok {
				arg := &PPlotSelectEnd{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotEdit
func goPPlotEdit(p unsafe.Pointer, N1 int32, N2 int32, N3 float32, N4 float32, N5 *float32, N6 *float32) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotEdit"]; ok {
			if fn, ok := f.(func(*PPlotEdit)); ok {
				arg := &PPlotEdit{h, DEFAULT, N1, N2, N3, N4, N5, N6}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotEditBegin
func goPPlotEditBegin(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotEditBegin"]; ok {
			if fn, ok := f.(func(*PPlotEditBegin)); ok {
				arg := &PPlotEditBegin{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotEditEnd
func goPPlotEditEnd(p unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotEditEnd"]; ok {
			if fn, ok := f.(func(*PPlotEditEnd)); ok {
				arg := &PPlotEditEnd{h, DEFAULT}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotPreDraw
func goPPlotPreDraw(p unsafe.Pointer, N1 unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotPreDraw"]; ok {
			if fn, ok := f.(func(*PPlotPreDraw)); ok {
				arg := &PPlotPreDraw{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goPPlotPostDraw
func goPPlotPostDraw(p unsafe.Pointer, N1 unsafe.Pointer) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["PPlotPostDraw"]; ok {
			if fn, ok := f.(func(*PPlotPostDraw)); ok {
				arg := &PPlotPostDraw{h, DEFAULT, N1}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goWebBrowserCompleted
func goWebBrowserCompleted(p unsafe.Pointer, N1 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["WebBrowserCompleted"]; ok {
			if fn, ok := f.(func(*WebBrowserCompleted)); ok {
				arg := &WebBrowserCompleted{h, DEFAULT, C.GoString(N1)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goWebBrowserError
func goWebBrowserError(p unsafe.Pointer, N1 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["WebBrowserError"]; ok {
			if fn, ok := f.(func(*WebBrowserError)); ok {
				arg := &WebBrowserError{h, DEFAULT, C.GoString(N1)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goWebBrowserNavigate
func goWebBrowserNavigate(p unsafe.Pointer, N1 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["WebBrowserNavigate"]; ok {
			if fn, ok := f.(func(*WebBrowserNavigate)); ok {
				arg := &WebBrowserNavigate{h, DEFAULT, C.GoString(N1)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}

//export goWebBrowserNewWindow
func goWebBrowserNewWindow(p unsafe.Pointer, N1 *C.char) int32 {
	ih := ptoHandle(p)
	if ih == nil {
		return DEFAULT
	}
	if h, ok := ih.(*Handle); ok {
		if f, ok := h.funcs["WebBrowserNewWindow"]; ok {
			if fn, ok := f.(func(*WebBrowserNewWindow)); ok {
				arg := &WebBrowserNewWindow{h, DEFAULT, C.GoString(N1)}
				fn(arg)
				return arg.Return
			}
		}
	}
	return DEFAULT
}
